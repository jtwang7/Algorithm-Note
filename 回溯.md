# 刷题记录
- [x] <a href='#017'>17. 电话号码的字母组合</a>
- [x] <a href='#022'>22. 括号生成</a>
- [x] <a href='#039'>39. 组合总和</a>
- [x] <a href='#081'></a>

# 题解
## <a id='017' href='https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/'>17. 电话号码的字母组合</a>
```js
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function (digits) {
  const res = [];
  const str = [];
  // 哈希表方便索引
  const map = {
    '2': ['a', 'b', 'c'],
    '3': ['d', 'e', 'f'],
    '4': ['g', 'h', 'i'],
    '5': ['j', 'k', 'l'],
    '6': ['m', 'n', 'o'],
    '7': ['p', 'q', 'r', 's'],
    '8': ['t', 'u', 'v'],
    '9': ['w', 'x', 'y', 'z'],
  }

  // 回溯
  const backTracking = (idx) => {
    // 终止条件
    if (str.length === digits.length) {
      res.push(str.join(''));
      return;
    }

    // 子集节点横向遍历
    for (let i = 0; i < map[digits[idx]].length; i++) {
      str.push(map[digits[idx]][i]); // 更新路径
      backTracking(idx + 1); // 纵向递归遍历
      str.pop(); // 状态回溯
    }
  }

  if (!digits) return [];
  backTracking(0);
  return res;
};
```


## <a id='022' href='https://leetcode-cn.com/problems/generate-parentheses/'>22. 括号生成</a>
```js
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function (n) {
  const res = []; // 存储结果
  const path = []; // 存储回溯路径
  const map = ['(', ')']; // 横向遍历可选项

  // 回溯函数
  const backTracking = (left, right) => {
    // 终止条件：生成n对括号，意味着最终树的深度为 2*n
    if (path.length === n * 2) {
      left === right && res.push(path.join('')); // 符合条件的结果：左括号数目 === 右括号数目
      return; // 结束递归
    }

    // 横向遍历
    for (let i = 0; i < 2; i++) {
      // 输入左括号
      if (i === 0) {
        if (left <= n) {
          path.push(map[i]);
          backTracking(left + 1, right); // 左括号数目 + 1，由于本层的 left 状态保存在参数中了，因此不需要额外的状态回溯
          path.pop();
        }
        // 剪枝：若左括号数目大于括号对数时，结果必然不可能成对，跳出
        continue
      }

      // 输入右括号
      if (i === 1) {
        if (left > right) {
          path.push(map[i]);
          backTracking(left, right + 1);
          path.pop();
        }
        continue;
      }
    }
  };

  backTracking(0, 0);
  return res;
}
```


## <a id='039' href='https://leetcode-cn.com/problems/combination-sum/'>39. 组合总和</a>
```js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function (candidates, target) {
  const res = []; // 存放最终结果集
  const path = []; // 存放本次回溯路径结果

  // 回溯函数
  // 1. 回溯函数一般返回 void
  // 2. 回溯函数参数需要根据实际需要添加，即先确定几个必要的参数，后续需要用到什么再声明什么

  const backTracking = (sum, startIdx) => {
    // 回溯终止条件：当组合总和等于 target 时，终止回溯，并将符合条件的路径存入最终结果集
    if (sum >= target) {
      sum === target && res.push([...path]);
      return;
    }

    // 回溯横向遍历：遍历对象是树结构的各个子节点
    // 横向遍历的宽度决定了树结构节点上的子集大小，宽度由 startIdx 和 length 决定
    // 以候选集 [2, 3, 5] 为例，横向宽度 [1, 2] 表示遍历的子集为 [3, 5]
    // 控制 startIdx 可以对要进行遍历的节点子集进行筛选过滤
    for (let i = startIdx; i < candidates.length; i++) {
      path.push(candidates[i]);
      backTracking(sum + candidates[i], i);
      path.pop(); // 回溯：弹出目标元素，回到之前的状态
    }
  }

  backTracking(0, 0);
  return res;
};
```